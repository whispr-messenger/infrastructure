apiVersion: batch/v1
kind: Job
metadata:
  name: vault-bootstrap-job
  namespace: vault
  annotations:
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: BeforeHookCreation
    argocd.argoproj.io/sync-wave: "5"
spec:
  ttlSecondsAfterFinished: 300
  template:
    spec:
      serviceAccountName: vault-config
      restartPolicy: OnFailure
      containers:
        - name: vault-config
          image: ghcr.io/whispr-messenger/vault-config-job:sha-4cea5de
          env:
            - name: VAULT_ADDR
              value: http://vault.vault.svc:8200
            - name: VAULT_TOKEN
              valueFrom:
                secretKeyRef:
                  name: vault-root-token
                  key: root_token
            - name: POSTGRES_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: postgresql
                  key: postgres-password
          command:
            - /bin/sh
            - -c
            - |
              set -e

              # curl and kubectl are already baked into the Docker image.
              # Only install packages not present in the base image.
              apk add --no-cache postgresql-client openssl

              echo "Waiting for Vault to be ready and unsealed..."
              until vault status | grep -q "Sealed.*false"; do
                echo "Vault not ready or still sealed, waiting..."
                sleep 5
              done

              echo "Vault is ready, starting bootstrap..."

              ####################################################################################################
              # Enable engines
              ####################################################################################################
              vault auth enable kubernetes 2>/dev/null || echo "Kubernetes auth already enabled"
              vault secrets enable database 2>/dev/null || echo "Database secrets engine already enabled"
              vault secrets enable -path=kv kv-v2 2>/dev/null || echo "KV secrets engine already enabled"
              vault auth enable github 2>/dev/null || echo "GitHub auth already enabled"
              vault write auth/github/config organization=whispr-messenger

              ####################################################################################################
              # Kubernetes auth configuration
              ####################################################################################################
              vault write auth/kubernetes/config \
                kubernetes_host=https://kubernetes.default.svc:443 \
                kubernetes_ca_cert=@/var/run/secrets/kubernetes.io/serviceaccount/ca.crt

              ####################################################################################################
              # Vault Config Operator bootstrap (policy + role for VCO service account)
              ####################################################################################################
              vault policy write vco-admin - <<EOF
              path "/*" {
                capabilities = ["create", "read", "update", "delete", "list", "sudo"]
              }
              EOF

              vault write auth/kubernetes/role/vco-admin \
                bound_service_account_names=default,controller-manager \
                bound_service_account_namespaces=vault-config-operator-system \
                policies=vco-admin \
                ttl=1h

              ####################################################################################################
              # JWT key generation (one-time)
              ####################################################################################################
              if ! vault kv get kv/whispr/shared/jwt >/dev/null 2>&1; then
                echo "Generating JWT RSA keys..."
                openssl genrsa -out /tmp/jwt_private.pem 2048
                openssl rsa -in /tmp/jwt_private.pem -pubout -out /tmp/jwt_public.pem

                vault kv put kv/whispr/shared/jwt JWT_PUBLIC_KEY="$(cat /tmp/jwt_public.pem)"
                vault kv put kv/whispr/auth-service/jwt JWT_PRIVATE_KEY="$(cat /tmp/jwt_private.pem)"

                rm /tmp/jwt_private.pem /tmp/jwt_public.pem
                echo "JWT keys generated and stored"
              else
                echo "JWT keys already exist in Vault"
              fi

              ####################################################################################################
              # Redis — Phase A: password lifecycle
              # Source of truth priority: Vault KV → K8s Secret → generate new
              # On every run: both stores (Vault KV + K8s Secret) are kept in sync.
              ####################################################################################################
              echo "Resolving Redis password..."
              REDIS_PASSWORD=$(vault kv get -field=REDIS_SENTINEL_PASSWORD kv/whispr/shared/redis 2>/dev/null || true)

              if [ -z "$REDIS_PASSWORD" ]; then
                echo "Vault KV has no Redis password, checking K8s secret..."
                REDIS_PASSWORD=$(kubectl get secret redis -n redis -o jsonpath='{.data.redis-password}' 2>/dev/null | base64 -d || true)
              fi

              if [ -z "$REDIS_PASSWORD" ]; then
                echo "No existing Redis password found — generating a new one..."
                REDIS_PASSWORD=$(openssl rand -base64 32 | tr -d '\n')
              fi

              echo "Syncing Redis password to Vault KV..."
              vault kv put kv/whispr/shared/redis REDIS_SENTINEL_PASSWORD="$REDIS_PASSWORD"

              echo "Syncing Redis password to K8s secret redis/redis..."
              kubectl create secret generic redis \
                --from-literal=redis-password="$REDIS_PASSWORD" \
                --namespace=redis \
                --dry-run=client -o yaml | kubectl apply -f -

              ####################################################################################################
              # Redis — Phase B: master discovery with stable headless DNS mapping
              # Sentinel returns an ephemeral pod IP; we map it to a stable headless
              # DNS hostname so Vault survives pod restarts.
              ####################################################################################################
              echo "Discovering Redis master via Sentinel..."
              MASTER_IP=$(redis-cli -h redis.redis.svc.cluster.local -p 26379 -a "$REDIS_PASSWORD" --no-auth-warning SENTINEL get-master-addr-by-name mymaster 2>/dev/null | head -1 || true)

              if [ -z "$MASTER_IP" ]; then
                echo "WARNING: Sentinel discovery failed, falling back to ClusterIP service"
                MASTER_HOST="redis.redis.svc.cluster.local"
              else
                MASTER_POD=$(kubectl get pods -n redis -o wide --no-headers 2>/dev/null \
                  | awk -v ip="$MASTER_IP" '$6 == ip {print $1}')
                if [ -n "$MASTER_POD" ]; then
                  MASTER_HOST="${MASTER_POD}.redis-headless.redis.svc.cluster.local"
                  echo "Master pod: $MASTER_POD → $MASTER_HOST"
                else
                  echo "WARNING: Could not map IP $MASTER_IP to a pod, using raw IP as fallback"
                  MASTER_HOST="$MASTER_IP"
                fi
              fi

              ####################################################################################################
              # Redis — Phase C: persist master host in Vault DB engine (re-syncs on every run)
              ####################################################################################################
              echo "Writing Redis connection to Vault DB engine (host: $MASTER_HOST)..."
              vault write database/config/redis \
                plugin_name=redis-database-plugin \
                allowed_roles="*" \
                host="$MASTER_HOST" \
                port=6379 \
                username="default" \
                password="$REDIS_PASSWORD" \
                verify_connection=true

              ####################################################################################################
              # PostgreSQL database connection (first time only)
              ####################################################################################################
              export PGPASSWORD="$POSTGRES_PASSWORD"

              if vault read database/config/postgres >/dev/null 2>&1; then
                echo "PostgreSQL connection already configured, skipping"
              else
                vault write database/config/postgres \
                  plugin_name=postgresql-database-plugin \
                  allowed_roles="*" \
                  connection_url="postgresql://{{username}}:{{password}}@postgresql.postgresql.svc.cluster.local:5432/postgres?sslmode=disable" \
                  username="postgres" \
                  password="$POSTGRES_PASSWORD"
              fi

              ####################################################################################################
              # PostgreSQL databases and schema grants
              ####################################################################################################
              for svc in auth-service user-service messaging-service notification-service media-service scheduling-service; do
                svc_underscore=$(echo $svc | tr '-' '_')
                DB_NAME="${svc_underscore}_db"

                psql -h postgresql.postgresql.svc.cluster.local -U postgres \
                  -c "CREATE DATABASE \"${DB_NAME}\";" || echo "Database ${DB_NAME} already exists"

                psql -h postgresql.postgresql.svc.cluster.local -U postgres -d "${DB_NAME}" \
                  -c "GRANT ALL ON SCHEMA public TO PUBLIC;"
              done

              ####################################################################################################
              # Messaging-service app secrets (one-time)
              ####################################################################################################
              if ! vault kv get kv/whispr/messaging-service/secrets >/dev/null 2>&1; then
                echo "Generating messaging-service app secrets..."
                vault kv put kv/whispr/messaging-service/secrets \
                  SECRET_KEY_BASE="$(openssl rand -base64 64 | tr -d '\n')" \
                  ENCRYPTION_KEY="$(openssl rand -base64 32 | tr -d '\n')"
                echo "messaging-service app secrets generated and stored"
              else
                echo "messaging-service app secrets already exist in Vault"
              fi

              echo "Vault bootstrap completed. Microservice roles, policies and auth roles are managed by Vault Config Operator CRs."
