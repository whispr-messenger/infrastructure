apiVersion: v1
kind: ServiceAccount # --> ServiceAccount = Identity for pods --> For AuthorizationPolicy, using SA identity
metadata:
  name: app-a
  namespace: whispr-prod
---

apiVersion: apps/v1
kind: Deployment
metadata:
  name: app-a
  namespace: whispr-prod
  labels:
    app: app-a

spec:
  replicas: 1
  
  selector:
    matchLabels:
      app: app-a
  
  template:
    metadata:
      labels:
        app: app-a
    
    spec:
      serviceAccountName: app-a
      
      nodeSelector:
        kubernetes.io/hostname: test-worker      
      tolerations:
      - key: zone
        operator: Equal
        value: test
        effect: NoSchedule
      
      containers:
      - name: app
        image: nginx:alpine
        ports:
        - containerPort: 80
        
        volumeMounts:
        - name: html
          mountPath: /usr/share/nginx/html
      
      volumes:
      - name: html
        configMap:
          name: app-a-html

---

apiVersion: v1
kind: ConfigMap
metadata:
  name: app-a-html
  namespace: whispr-prod

data:
  # Data of ConfigMap
  index.html: |
    <!DOCTYPE html>
    <html>
    <head><title>App A - Frontend</title></head>
    <body style="font-family: Arial; padding: 50px;">
      <h1>Application A - Frontend</h1>
      <p><strong>Envoy Proxy:</strong> Injected by Istio</p>
      <p><strong>Node:</strong> test-worker</p>
      <hr>
      <button onclick="fetch('/api').then(r=>r.text()).then(t=>alert(t))">
        Call Backend (App B)
      </button>
    </body>
    </html>

---

apiVersion: v1
kind: Service
metadata:
  name: app-a
  namespace: whispr-prod
  labels:
    app: app-a

spec:
  selector:
    app: app-a # --> Service route toward pods with label
  
  ports:
  - port: 80
    targetPort: 80
    name: http # --> Name port (requiert by Istio --> protocol detection)